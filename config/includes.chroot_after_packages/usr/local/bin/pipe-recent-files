#!/bin/bash

# Openbox pipemenu to create a list of recent files with icons
# (if you don't care about icons this will be a waste of resources)
# also see: forums.bunsenlabs.org/viewtopic.php?pid=111438#p111438

### Dependencies:
# - xmlstarlet                  parsing recentfile
### Optional:
# - gio (glib2, libglib2-bin)   redefine useless mimetypes

# Options:
# -r str  Recentfile to parse (default: $HOME/.local/share/recently-used.xbel)
# -c      Clear the recentfile
# 
# -d      Output a little more to stderr
# -s str  Comma-separated list of icon sizes to consider. Default 22,24,32
# -t str  Comma-separated list of Icon theme names to consider. No default.
#         Example: "Tela,Papirus,Paper"
# -m int  maximum number of results to display

max=12 # maximum number of recent files
# Comma-separated list of Desired icon sizes.
# Choose something that is actually found in icon themes.
isizes=22,24,32
debug=0
recentfile="$HOME/.local/share/recently-used.xbel"
gtksettingsfile="${XDG_CONFIG_HOME-"$HOME/.config"}/gtk-3.0/settings.ini"

G() {
    # simplistic grep replacement
    # only works on files, only the first match is assigned to a variable
    # $1: query
    # $2: file
    # $3: variable to use
    while read -r line; do
        [[ "$line" == *"$1"* ]] && declare -g "$3"="$line" && return
    done <"$2"
}
# This function will return exactly one icon for a mimetype
findicon() {
    mime="$1"
    queries="${2-"mimetypes,mimes"}" # comma-separated list of icon type subfolders

    shopt -s nullglob # required to recognize empty results

    # If the user didn't define iconthemes, we extract the current one from
    # gtk3's settings.ini and append the "Inherits" found in that theme's index.theme.
    # Warning: many icon themes have a messy inherits
    if [[ "$iconthemes" == "" ]]; then
        G gtk-icon-theme-name "$gtksettingsfile" iconthemes
        iconthemes="${iconthemes##*=}"
        iconthemes="${iconthemes#*\"}"
        iconthemes="${iconthemes%\"*}"
        for path in "$HOME/.local/share/icons" "/usr/share/icons"; do
            path="$path/$iconthemes/index.theme"
            [ -r "$path" ] && break
        done
        G 'Inherits=' "$path" inherits
        iconthemes="${iconthemes},${inherits#*=}"
    fi

    src_icon=""
    for theme in ${iconthemes//,/ }; do
        for path in "$HOME/.local/share/icons" "/usr/share/icons"; do
            path="$path/$theme"
            [ -d "$path" ] || continue
            echo "Icon lookup @ $path" >&2
            for isize in ${isizes//,/ }; do
                for dir1 in "$isize" "${isize}x$isize" scalable; do
                    for dir2 in ${queries//,/ }; do
                        for dir in "$dir1/$dir2" "$dir2/$dir1"; do
                            [ -d "$path/$dir" ] || continue
                            for src_icon in "$path/$dir/$mime".???; do [ -r "$src_icon" ] && break 7; done
                            for src_icon in "$path/$dir/"*"-$mime".???; do [ -r "$src_icon" ] && break 7; done
                        done
                    done
                done
            done
        done
    done
    # no results? OK, no icon then, and return 1 == error
    [[ "$src_icon" == "" ]] && return 1
    echo "$src_icon"
}
pipe_exit() {
    echo "<item label=\"$*\" /></openbox_pipe_menu>"
    exit 1
}
######################### MAIN ###############################

echo "<openbox_pipe_menu>"

while getopts "dcs:t:m:r:" opt; do
    case $opt in
        d)  debug=1
        ;;
        c)
            cat <<EOF > "$recentfile"
<?xml version="1.0" encoding="UTF-8"?>
<xbel version="1.0"
      xmlns:bookmark="http://www.freedesktop.org/standards/desktop-bookmarks"
      xmlns:mime="http://www.freedesktop.org/standards/shared-mime-info"
>
</xbel>
EOF
        exit
        ;;
        s) isizes="$OPTARG"
        ;;
        t)  # a comma-separated list of icon theme names to search for mimetype icons
            # overrides automatic detection
            iconthemes="$OPTARG"
        ;;
        m)  [[ "$OPTARG" =~ [0-9]+ ]] && (( OPTARG >= 0 )) && (( OPTARG <= 65535 )) || pipe_exit "Option -${opt}: invalid number $OPTARG"
            max="$OPTARG"
        ;;
        r)  recentfile="$OPTARG"
        ;;
    esac
done

# quick dependency check
for dep in xmlstarlet; do
    type "$dep" >/dev/null || exit 1
done

[ -r "$recentfile" ] || pipe_exit "No Recent Files"
# [ -r "$recentfile" ] || pipe_exit "Cannot read ${recentfile/$HOME/\~}"
# Use an Xpath expression to collect all
# 1) file:///...
# 2) mime-type
# 3) application
# elements, sorted by last modified date. Read into array and limit to $max elements.
mapfile -n "$((max*3))" -t array <<<"$(xmlstarlet sel -t -m "/xbel/bookmark" -s D:T:U '@modified' \
-v '@href' -n \
-v 'info/metadata/mime:mime-type/@type' -n \
-v 'info/metadata/bookmark:applications/bookmark:application[last()]/@exec' -n "$recentfile")"
[[ "$array" == "" ]] && pipe_exit "No file data to process"

mimetypestofix=()
j=0
# Converting file:/// elements to proper unix paths:
for ((i=0;i<${#array[@]};i++)); do
    # file path
    array[i]="${array[i]#*file://}"
    array[i]="${array[i]%\"*}"
    array[i]="${array[i]//%20/ }"
    ((i++))
    # mime-type - keep only the part after the /
    array[i]="${array[i]#*/}"
    # if the mime-type is the useless octet-stream, collect files to re-test with gio:
    if [[ "${array[i]}" == "octet-stream" ]]; then
        mimetypestofix[$((j++))]="${array[$((i-1))]}"
    fi
    ((i++))
    # command to open file
    # remove single quotes
    array[i]="${array[i]//\'/}"
    # replace %u with quoted file path
    array[i]="${array[i]//%u/\"${array[$((i-2))]}}\""
done

mimetypesfixed=()
if type gio >/dev/null && [[ "$mimetypestofix" != "" ]]; then
    # We need to fix the stupid octet-stream mimetype.
    # to get only the last line of the gio output for each file we use mapfile with
    # a callback function, see: wiki.bash-hackers.org/commands/builtin/mapfile#the_callback
    mtf() { mimetypesfixed[$(($1/5))]="${2##*/}"; }
    mapfile -t -c 5 -C 'mtf ' <<<"$(gio info -a standard::content-type "${mimetypestofix[@]}")"
fi
if [[ "$debug" == 1 ]]; then
    for ((i=0;i<${#array[@]};i++)); do
        echo -e "$((i/3))\t${array[i]}"
    done
    echo "########################"
    for ((i=0;i<${#mimetypestofix[@]};i++)); do
        echo -e "$((i))\t${mimetypestofix[i]}"
    done
    echo "########################"
    for ((i=0;i<${#mimetypesfixed[@]};i++)); do
        echo -e "$((i))\t${mimetypesfixed[i]}"
    done
fi >&2

# go through the array 3 lines at a time, and output openbox pipemenu stuff:
for ((i=0,j=0;i<${#array[@]};i+=3)); do
    # 1st line: the file path
    # 2nd line: the mimetype
    # 3rd line: the command to execute

    # 1. the file - skip if unreadable
    [ -r "${array[i]}" ] || continue
    # label of the menu entry - openbox-specific
    label="${array[i]/$HOME/\~}"
    label="${label//_/__}"

    # 2. The mimetype
    type="${array[$((i+1))]}"
    if [[ "$mimetypesfixed" != "" ]]; then
        echo "unfixed $type" >&2
        [[ "$type" == "octet-stream" ]] && type="${mimetypesfixed[$((j++))]}"
        echo "fixed   $type" >&2
    fi
    # find a suitable icon
    icon="$(findicon "$type" || findicon unknown)"

    # 3. the command
    cmd="${array[$((i+2))]}"

    # finally print out the recent item
    echo "<item label=\"$label \" icon=\"$icon\"><action name=\"Execute\"><command><![CDATA[$cmd]]></command></action></item>"
done

# close up the pipemenu, with one last entry to remove $recentfile and a suitable "delete" icon
icon="$(findicon delete actions)"
echo "<separator /><item icon=\"$icon\" label=\"Clear Recents\"><action name=\"Execute\"><prompt>Really delete ${recentfile//$HOME/\~}?</prompt><command><![CDATA[\"$0\" -c]]></command></action></item></openbox_pipe_menu>"
